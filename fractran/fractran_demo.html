<!doctype html>
<html>
<head>
<meta charset="utf-8">
<link rel="icon" href="frac.png">
<link rel="image_src" href="frac.png">
<link rel="stylesheet" href="mathquill-basic.css"/>
<script src="jquery-3.3.1.min.js"></script>
<script src="mathquill-fractran.js"></script>
<script src="tkas_fractran.js"></script>
<meta name=description content="">
<title> Fractran </title>
<script>

var MQ = MathQuill.getInterface(2);

var cursor_str = "<span style='border-left: 1px solid black; margin-left:-1px;padding:0'>&#8203;</span>";

var prime_list = [2]; //DO NOT ACCESS DIRECTLY, use nth_prime

function nth_prime(n) {
	while (!(n in prime_list)) {
		var k = prime_list[prime_list.length-1] + 1;
		var new_prime_found = false;
		a: while (!new_prime_found) {
			var i;
			for (i = 0; prime_list[i] <= Math.sqrt(k); i++) {
				if (k % prime_list[i] == 0) {k++; continue a;}
				}
			new_prime_found = true;
			prime_list.push(k);
			}
		}
	return(prime_list[n]);
	}

function prime_factor(n) {
	if ((!Number.isInteger(n))||(n<=0)) {console.log("prime_factor error: bad input ", n); return([]);}
	var rval = [];
	var handled = 1;
	var unhandled = n;
	var i, k, j, p;
	for (i = 0; handled != n; i++) {
		p = nth_prime(i);
		j = 1;
		k = 0;
		while (unhandled % (j*p) == 0) {
			k++;
			j *= p;
			}
		rval.push(k);
		unhandled /= j;
		if (!Number.isInteger(unhandled)) {console.log("prime_factor error: no longer integer ", unhandled); return([]);}
		handled *= j;
		}
	return(rval);
	}

function mapmany(f,n) {//returns[f(0),...,f(n-1)]
	var rval = [];
	var i;
	for (i = 0; i < n; i++) {
		rval.push([f(i)]);
		}
	return(rval);
	}

var light_colors = ["#EEDD88", "#77AADD", "#EE8866", "#FFAABB", "#99DDFF", "#44BB99", "#BBCC33", "#AAAA00", "#DDDDDD"]; //from https://personal.sron.nl/~pault/
function hi_color(n) {
	return(light_colors[n%9]);
	}
var passcolor = "#33BBEE";
var failcolor = "#EE7733";
var passstr = "<span style='background-color:"+passcolor+"'>Passed!</span>";
var failstr = "<span style='background-color:"+failcolor+"'>Failed!</span>";

function html_label_arrow(txt) {
	return("<span style='position:relative'><span style='position:absolute;top:.4em;left:-.2em;right:0; text-align:center;font-size:60%'>"+txt+"</span>&#8594;</span>");
	}

function number_to_letter(n) {
	if (n < 26) {return(String.fromCharCode(65+n));}
	if (n < 52) {return(String.fromCharCode(97-26+n));}
	return(n);
	}

function color_letter(i) {
	return("<span style='background-color:"+hi_color(i)+"'>"+number_to_letter(i)+"</span>");
	}

function arrowtron(i) {
	return("&nbsp;"+html_label_arrow(color_letter(i))+"&nbsp;");
	}

function printlist(l) {
	if (!(Array.isArray(l))) {return(l);}
	var i;
	var rval = "["
	for (i = 0; i < l.length; i++) {
		if (i > 0) {rval += ","}
		rval += printlist(l[i]);
		}
	rval += "]";
	return(rval);
	}

function insert_into_string(str,c,p) {
	return(str.slice(0,p) + c + str.slice(p));
	}

function remove_from_string(str,p) {
	var rval = "";
	var i;
	for (i = 0; i < str.length; i++) {
		if (i != p) {rval += str[i]};
		}
	return(rval);
	}

function remove_from_array(l,p) {
	var rval = [];
	var i;
	for (i = 0; i < l.length; i++) {
		if (i != p) {rval.push(l[i])};
		}
	return(rval);
	}

function pl_to_int(l) {
	var i;
	var rval = 1;
	for (i = 0; i < l.length; i++) {
		if (l[i] == "") {
			}
		else {
			rval *= Math.pow(nth_prime(i),l[i]);
			}
		}
	return(rval);
	}

function rawpl_to_int(l) {
	var i;
	var rval = 1;
	for (i = 0; i < l.length; i++) {
		rval *= Math.pow(l[i][0],l[i][1]);
		}
	return(rval);
	}

function fl_max_power(l) {
	var rval = 0;
	var i;
	for (i = 0; i < l.length; i++) {
		rval = Math.max(rval, l[i][0].length, l[i][1].length);
		}
	return(rval);
	}

function rawpl_to_html(l, opts) {
	var default_options = {
		dot_after_exponents: true,
		zero_exponents: "hide", //can be "hide", "dim", "show"
		one_exponents: "hide", //can be "hide", "dim", "show"
		actually_numbers: false,
		}
	opts = Object.assign({},default_options,opts);

	if (opts.actually_numbers) { return(pl_to_int(rawpl_to_pl(l)));}

	var i;
	var rval = "";
	var needs_dot = false;
	var expstr;
	
	var isempty = true;
	for (i = 0; i < l.length; i++) {
		if (l[i][1] != 0) {isempty = false;}
		}
	if (isempty) {return("1<sup></sup>");}

	for (i = 0; i < l.length; i++) {
		expstr = l[i][1];
		var old_needs_dot = needs_dot;
		if (l[i][1] == 0) {
			if (opts.zero_exponents == "hide") {
				//rval += "<sup></sup>";
				continue;
				}
			else if (opts.zero_exponents == "dim") {
				needs_dot = true;
				expstr = "<span style='color:gray'>" + expstr + "</span>";
				}
			else if (opts.zero_exponents == "show") {
				needs_dot = true;
				}
			}
		else if (l[i][1] == 1) {
			if (opts.one_exponents == "hide") {
				needs_dot=true;
				expstr = "";
				}
			else if (opts.one_exponents == "dim") {
				needs_dot = true;
				expstr = "<span style='color:gray'>" + expstr + "</span>";
				}
			else if (opts.one_exponents == "show") {
				needs_dot = true;
				}
			}
		else {
			needs_dot = opts.dot_after_exponents;
			}
		if (old_needs_dot) {rval += "&middot;"}
		rval += "" + l[i][0] + "<sup>" + expstr + "</sup>";
		}
	return(rval);
	}

function fracstrings(s1,s2) {
	var rval = "<table style='display:inline-block;vertical-align:middle; border-spacing:0px'><tr><td style='height:1.5em;text-align:center; padding:0px; border-bottom:solid 2px'>" + s1 + "</td></tr><tr><td style='height:1.5em;text-align:center'>" + s2 + "</td></tr></table>";
	return(rval);
	}

function rawplfrac_to_html(l1,l2,opts) {
	return(fracstrings(rawpl_to_html(l1,opts),rawpl_to_html(l2,opts)));
	}

function rawfl_to_html(l, opts) {

	var i;
	var rval = "";
	for (i = 0; i < l.length; i++) {
		if (i > 0) {rval += ",<span style='width:1em'>&nbsp;</span>";}
		rval += rawplfrac_to_html(l[i][0],l[i][1], opts);
		}
	return(rval);
	}


function apply_f_to_l(l,f) { //attempt to apply fraction(in list form) to list, return "nope" if failure
	var i;
	var rval = [];
	for (i = 0; i < l.length; i++) {
		rval.push(l[i]);
		}
	for (i = 0; i < f[1].length; i++) {
		if (f[1][i] > 0 && (!(i in l))) {return("nope");}
		if (f[1][i] > l[i]) {return("nope");}
		rval[i] -= f[1][i];
		}
	for (i = 0; i < f[0].length; i++) {
		if (!(i in l)) {rval.push(0);}
		rval[i] += f[0][i];
		}
	return(rval);
	}

function testing_apply_f_to_l(wl,wn,wd) {
	var l = prime_factor(wl);
	var f = [prime_factor(wn),prime_factor(wd)];
	var r = apply_f_to_l(l,f);
	if (r != "nope") {
		r = pl_to_int(r);
		}
	return(r);
	}

function apply_fl_to_l_and_which(l, fl) { //attempt to apply fractionlist (each in list form) to list, return "nope" if failure, return pair [fi(l), i]
	var i;
	var t;
	for (i = 0; i < fl.length; i++) {
		var t = apply_f_to_l(l, fl[i]);
		if (t != "nope") {
			return([t,i]);
			}
		}
	return("nope");
	}

function apply_fl_to_l(l, fl) { //attempt to apply fractionlist (each in list form) to list, return "nope" if failure
	var i;
	var t;
	for (i = 0; i < fl.length; i++) {
		var t = apply_f_to_l(l, fl[i]);
		if (t != "nope") {
			return(t);
			}
		}
	return("nope");
	}

function iterated_apply_fl_to_l(l, fl) { //apply fl to l repeatedly until it can't. return "loop" if loops
	var action_list = [pl_to_int(l)];
	var curl = l;
	var b = true;
	while (b) {
		curl = apply_fl_to_l(curl, fl);
		if (curl == "nope") {b = false;}
		else if (action_list.indexOf(pl_to_int(curl)) != -1) {console.log(action_list); return("loop")}
		else {action_list.push(pl_to_int(curl));}
		}
	console.log(action_list);
	return(action_list[action_list.length-1]);
	}

function iapp(n) {
	var l = prime_factor(n);
	var k = iterated_apply_fl_to_l(l, g_fracl);
	return(k);
	}

function str_to_rawpl(str) { //converts a string 2^3*4^6*5 etc into a power list (with unsorted, nonprime bases),
	var l = str.split("*");
	var i;
	var rval = [];
	for (i = 0; i < l.length; i++) {
		var k = l[i].split("^");
		if (k.length == 1) {
			var b = Number(k[0]);
			if (!Number.isInteger(b) || b <= 0) {console.log("parse failed at ", l[i]);}
			rval.push([b,1]);
			}
		if (k.length == 2) {
			var b = Number(k[0]);
			if (!Number.isInteger(b) || b <= 0) {console.log("parse failed at ", l[i]);}
			var e = Number(k[1]);
			if (!Number.isInteger(e)) {console.log("parse failed at ", l[i]);}
			rval.push([b,e]);
			}
		}
	return(rval);
	}

function str_to_rawfl(str) {
	var l = str.split(/\s|,/);
	var i;
	var rval = [];
	for (i = 0; i < l.length; i++) {
		if (l[i] == "") {continue;}
		var k = l[i].split("/");
		if (k.length == 1) {
			rval.push([str_to_rawpl(k[0]), []]);
			}
		if (k.length == 2) {
			rval.push([str_to_rawpl(k[0]), str_to_rawpl(k[1])]);
			}
		}
	return(rval);
	}

function str_looks_like_a_rawpl(str) {
	var l = str.split("*");
	var i;
	for (i = 0; i < l.length; i++) {
		var k = l[i].split("^");
		if (k.length == 1) {
			var b = Number(k[0]);
			if (!Number.isInteger(b) || b <= 0) {return(false);}
			}
		else if (k.length == 2) {
			var b = Number(k[0]);
			if (!Number.isInteger(b) || b <= 0) {return(false);}
			var e = Number(k[1]);
			if (!Number.isInteger(e)) {return(false);}
			}
		else {return(false);}
		}
	return(true);
	}

function str_looks_like_a_rawfl(str) {
	var l = str.split(/\s|,/);
	var i;
	for (i = 0; i < l.length; i++) {
		if (l[i] == "") {continue;}
		var k = l[i].split("/");
		if (k.length == 1) {
			if (!str_looks_like_a_rawpl(k[0])) {return(false);}
			}
		else if (k.length == 2) {
			if (!str_looks_like_a_rawpl(k[0])) {return(false);}
			if (!str_looks_like_a_rawpl(k[1])) {return(false);}
			}
		else {
			return(false);
			}
		}
	return(true);
	}

function rawpl_to_str(l) {
	var i;
	var str = "";
	var needs_dot = false;
	for (i = 0; i < l.length; i++) {
		if (l[i][1] == 0) {continue;}
		else if (l[i][1] == 1) {
			if (needs_dot) {str += "*";}
			str += l[i][0]; 
			needs_dot = true;
			}
		else {
			if (needs_dot) {str += "*";}
			str += l[i][0] + "^" + l[i][1]; 
			needs_dot = true;}
		}
	if (str == "") {str = "1";}
	return(str);
	}

function rawfl_to_str(l) {
	var i;
	var str = "";
	for (i = 0; i < l.length; i++) {
		if (i > 0) {str += ", ";}
		str += rawpl_to_str(l[i][0]) + "/" + rawpl_to_str(l[i][1]);
		}
	return(str);
	}

function tk_override_mq_paste(str) {
	if (str_looks_like_a_rawfl(str)) {
		return(rawfl_to_latex(str_to_rawfl(str)));
		}
	return(str);
	}

//22^3*4^5/3^3*2^10
//22^{30}\cdot4^5

function rawpl_to_latex(l) {
	var i;
	var str = "";
	var needs_dot = false;
	for (i = 0; i < l.length; i++) {
		if (l[i][1] == 0) {continue;}
		else if (l[i][1] == 1) {
			if (needs_dot) {str += "\\cdot";}
			str += l[i][0]; 
			needs_dot = true;
			}
		else {
			if (needs_dot) {str += "\\cdot";}
			str += l[i][0] + "^{" + l[i][1] + "}"; 
			needs_dot = true;
			}
		}
	if (str == "") {str = "1";}
	return(str);
	}

function rawfl_to_latex(l) {
	var i;
	var str = "";
	for (i = 0; i < l.length; i++) {
		if (i > 0) {str += ", ";}
		str += "\\frac{"+rawpl_to_latex(l[i][0])+"}{"+rawpl_to_latex(l[i][1])+"}";
		}
	return(str);
	}

function rawpl_to_pl(l) {
	var i;
	var factoredbases = [];
	var maxl = 0;
	for (i = 0; i < l.length; i++) {
		var t = prime_factor(l[i][0]);
		factoredbases.push(t);
		maxl = Math.max(t.length, maxl);
		}
	var rval = [];
	for (i = 0; i < maxl; i++) {
		rval.push(0);
		}
	for (i = 0; i < l.length; i++) {
		for (j = 0; j < factoredbases[i].length; j++) {
			rval[j] += factoredbases[i][j] * l[i][1];
			}
		}
	return(rval);
	}

function rawfl_to_fl(l) {
	var i;
	var rval = [];
	var frontfracs = [];
	var maxprimen = 0;
	for (i = 0; i < l.length; i++) {
		maxprimen = Math.max(rawpl_to_pl(l[i][0]).length, rawpl_to_pl(l[i][1]).length, maxprimen);
		}
	for (i = 0; i < l.length; i++) {
		var t_num = rawpl_to_pl(l[i][0]);
		var t_den = rawpl_to_pl(l[i][1]);
		var j;
		if (! document.getElementById("chk_no_cancel").checked) {
			for (j = 0; j < Math.min(t_num.length,t_den.length); j++) {
				if (t_num[j] > 0 && t_den[j] > 0) {
					var t = Math.min(t_num[j],t_den[j]);
					t_num[j] -= t;
					t_den[j] -= t;
					}
				}
			}
		else {
			var needscancel = false;
			for (j = 0; j < Math.min(t_num.length, t_den.length); j++) {
				if (t_num[j] > 0 && t_den[j] > 0) {needscancel = true;}
				}
			if (needscancel) {
				var newprime = rawpl_to_pl([[nth_prime(maxprimen),1]]);
				frontfracs.push([t_num,newprime]);
				t_num = newprime;
				maxprimen++;
				}
			}
		rval.push([t_num,t_den]);
		}
	return(frontfracs.concat(rval));
	}

function pl_to_rawpl(l, extra_powers) {
	var i;
	var rval = [];
	for (i = 0; i < l.length; i++) {
		rval.push([nth_prime(i),l[i]]);
		}
	if (extra_powers) {
		for (i = l.length; i < extra_powers; i++)  {
			rval.push([nth_prime(i),0]);
			}
		}
	return(rval);
	}

function fl_to_rawfl(l, extra_powers) {
	var i;
	var rval = [];
	for (i = 0; i < l.length; i++) {
		var t_num = pl_to_rawpl(l[i][0], extra_powers);
		var t_den = pl_to_rawpl(l[i][1], extra_powers);
		rval.push([t_num,t_den]);
		}
	return(rval);
	}

function tkas_to_rawpls(L) { //returns pair (numerator, denominator)
	if (L.op == "NUM") {
		return([[[L.c,1]],[]]);
		}
	if (L.op == "POW") {
		return([[[L.subs[0].c,L.subs[1].c]],[]]);
		}
	if (L.op == "MUL") {
		var i;
		var r = [];
		for (i = 0; i < L.subs.length; i++) {
			if (L.subs[i].op == "NUM") {
				r.push([L.subs[i].c,1]);
				}
			if (L.subs[i].op == "POW") {
				r.push([L.subs[i].subs[0].c,L.subs[i].subs[1].c]);
				}
			}
		return([r,[]]);
		}
	if (L.op == "DIV") {
		var t1 = tkas_to_rawpls(L.subs[0])[0];
		var t2 = tkas_to_rawpls(L.subs[1])[0];
		return([t1,t2]);
		}
	console.log("FAILURE:", L);
	throw new Error("FAILURE");
	}

function gcd(a,b) {
	a = Math.abs(a);
	b = Math.abs(b);
	while(true) {
		if (b == 0) {return(a);}
		a = a % b;
		if (a == 0) {return(b);}
		b = b % a;
		}
	}

function add_number_fracs(f1,f2) {
	console.log(f1[1],f2[1]);
	var t = gcd(f1[1],f2[1]);
	var newden = (f1[1]*f2[1])/t;
	var newnum = (f1[0]*f2[1]+f1[1]*f2[0])/t;
	return([newnum,newden]);
	}

function fancy_tkas_to_rawpls(L) {
	if (L.op == "NUM") {
		return([[[L.c,1]],[]]);
		}
	if (L.op == "ADD") {
		var i;
		var curfrac = [0,1];
		for (i = 0; i < L.subs.length; i++) {
			var recur = fancy_tkas_to_rawpls(L.subs[i]);
			var num = pl_to_int(rawpl_to_pl(recur[0]));
			var den = pl_to_int(rawpl_to_pl(recur[1]));
			curfrac = add_number_fracs(curfrac,[num,den]);
			}
		return([pl_to_rawpl(prime_factor(curfrac[0])),pl_to_rawpl(prime_factor(curfrac[1]))]);
		}
	if (L.op == "MUL") {
		var i;
		var curnum = [];
		var curden = [];
		for (i = 0; i < L.subs.length; i++) {
			var recur = fancy_tkas_to_rawpls(L.subs[i]);
			curnum = curnum.concat(recur[0]);
			curden = curden.concat(recur[1]);
			}
		return([curnum,curden]);
		}
	if (L.op == "NEG") {
		var recur = fancy_tkas_to_rawpls(L.subs[0]);
		var newnum = [[-1,1],...recur[0]];
		return([newnum,recur[1]]);
		}
	if (L.op == "DIV") {
		var recur0 = fancy_tkas_to_rawpls(L.subs[0]);
		var recur1 = fancy_tkas_to_rawpls(L.subs[1]);
		return([recur0[0].concat(recur1[1]),recur0[1].concat(recur1[0])]);
		}
	if (L.op == "POW") {
		var recurb = fancy_tkas_to_rawpls(L.subs[0]);
		var recure = fancy_tkas_to_rawpls(L.subs[1]);
		var exp = rawpl_to_int(recure[0])/rawpl_to_int(recure[1]);
		var newnum = [];
		var newden = [];
		var i;
		for (i = 0; i < recurb[0].length; i++) {
			newnum.push([recurb[0][i][0],Math.round(recurb[0][i][1]*Math.abs(exp))]); //look, if you want fractional exponents, this isn't the place for them.
			}
		for (i = 0; i < recurb[1].length; i++) {
			newden.push([recurb[1][i][0],Math.round(recurb[1][i][1]*Math.abs(exp))]);
			}
		if (exp < 0) {
			return([newden,newnum]);
			}
		else {
			return([newnum,newden]);
			}
		}
	return(tkas_to_rawpls(L));
	};


var g_rawfl = [];
var g_fracl = [];

function old_do_flist_out() {

		//dot_after_exponents: true,
		//zero_exponents: "hide", //can be "hide", "dim", "show"
		//one_exponents: "hide", //can be "hide", "dim", "show"
		//actually_numbers: false

	var k = document.getElementById("sel_flist_out_type").value;
	var str;
	var g_fracl_rawfl = fl_to_rawfl(g_fracl);
	if (k == "in") {
		str = rawfl_to_html(g_rawfl);
		}
	if (k == "num") {
		str = rawfl_to_html(g_fracl_rawfl, {actually_numbers:true});
		}
	if (k == "pf1") {
		str = rawfl_to_html(g_fracl_rawfl);
		}
	if (k == "pf2") {
		str = rawfl_to_html(g_fracl_rawfl, {zero_exponents: "dim", one_exponents:"dim"});
		}
	if (k == "pf3") {
		str = rawfl_to_html(g_fracl_rawfl, {zero_exponents: "show", one_exponents:"show"});
		}
	if (k == "pf4") {
		g_fracl_rawfl = fl_to_rawfl(g_fracl, fl_max_power(g_fracl));
		str = rawfl_to_html(g_fracl_rawfl, {zero_exponents: "show", one_exponents:"show"});
		}
	document.getElementById("flist_out").innerHTML = str;
	}

function do_flist_out() {
	var str = "<table border=1 style='background-color:white; text-align:center'>";
	str += "<tr><td></td>";
	var i;
	var g_fracl_rawfl = fl_to_rawfl(g_fracl);
	for (i = 0; i < g_fracl.length; i++) {
		str += "<td style='text-align:center;background-color:"+hi_color(i)+"'>" + number_to_letter(i) + "</td>";
		}
	str += "</tr><tr><td>As Entered:</td>";
	for (i = 0; i < g_fracl.length - g_rawfl.length; i++) {
		str += "<td></td>";
		}
	for (i = 0; i < g_rawfl.length; i++) {
		str += "<td>" + rawplfrac_to_html(...g_rawfl[i]) + "</td>";
		}
	str += "</tr><tr><td>Raw Numbers:</td>";
	for (i = 0; i < g_fracl.length; i++) {
		str += "<td>" + rawplfrac_to_html(...g_fracl_rawfl[i], {actually_numbers:true}) + "</td>";
		}
	str += "</tr><tr><td>Factored Form:</td>";
	for (i = 0; i < g_fracl.length; i++) {
		str += "<td>" + rawplfrac_to_html(...g_fracl_rawfl[i]) + "</td>";
		}
	str += "</tr></table>";
	str += rawfl_to_str(g_fracl_rawfl);
	document.getElementById("flist_out").innerHTML = str;
	}

function do_chk_no_cancel() {
	do_input();
	}

function do_input() { //specific functions (do_text_in, do_mq_in) drop off data in g_rawfl, then call do_input to display the result, do other changes on changing the fraction list, update g_fracl

	reset_runtable();

	g_fracl = rawfl_to_fl(g_rawfl);

	do_flist_out();

	local_data.levels[g_current_level].program = g_rawfl;
	store_local_data();

	}

function do_ttext_in() {
	var str = document.getElementById("text_in").value;
	var T = tkas_parse(str);
	var i;
	var l = str.split(",");
	var r = [];
	for (i = 0; i < l.length; i++) {
		if (l[i] == "") {continue;}
		try {
			var L = tkas_parse(l[i]);
			r.push(fancy_tkas_to_rawpls(L));
			}
		catch(e) {}
		}
	g_rawfl = r;
	do_input();
	}

function do_text_in() {
	if (document.getElementById("sel_inp").value == "ttext") {do_ttext_in(); return;}
	var str = document.getElementById("text_in").value;
	g_rawfl = str_to_rawfl(str);
	do_input();
	}

function do_tmq_in(m) {
	var str = m.latex().replace(/{/g,"(").replace(/}/g,")");
	str = str.replace(/\\\s/,"");
	str = str.replace(/\\cdot/g,"*");
	str = str.replace(/\\left/g,"");
	str = str.replace(/\\right/g,"");
	var l = str.split(",");
	var i;
	var r = [];
	for (i = 0; i < l.length; i++) {
		if (l[i] == "") {continue;}
		try{
			var L = tkas_parse(l[i]);
			r.push(fancy_tkas_to_rawpls(L));
			}
		catch (e) {}
		}
	g_rawfl = r;
	do_input();
	}

function do_mq_in(m) {
	if (document.getElementById("sel_inp").value == "tmq") {do_tmq_in(m); return;}
	var str = m.latex().replace(/{/g,"(").replace(/}/g,")");
	str = str.replace(/\\frac/g,",\\frac").replace(/\\\s/,",");
	str = str.replace(/\\cdot/g,"*");
	var l = str.split(",");
	var i;
	var r = [];
	for (i = 0; i < l.length; i++) {
		if (l[i] == "") {continue;}
		try{
			var L = tkas_parse(l[i]);
			r.push(tkas_to_rawpls(L));
			}
		catch (e) {}
		}
	g_rawfl = r;
	do_input();
	}

function do_sel_inp() {
	var k = document.getElementById("sel_inp").value;
	document.getElementById("text_instructions").style.display = "none";
	document.getElementById("mq_instructions").style.display = "none";
	document.getElementById("tmq_instructions").style.display = "none";
	document.getElementById("ttext_instructions").style.display = "none";
	document.getElementById("text_in_area").style.display = "none";
	document.getElementById("demos_in_area").style.display = "none";
	document.getElementById("mq_in_area").style.display = "none";
	if (k == "demo") {
		document.getElementById("demos_in_area").style.display = "";
		}
	if (k == "text") {
		document.getElementById("text_in_area").style.display = "";
		document.getElementById("text_instructions").style.display = "";
		}
	if (k == "mq") {
		document.getElementById("mq_in_area").style.display = "";
		document.getElementById("mq_instructions").style.display = "";
		}
	if (k == "tmq") {
		document.getElementById("mq_in_area").style.display = "";
		document.getElementById("tmq_instructions").style.display = "";
		}
	if (k == "ttext") {
		document.getElementById("text_in_area").style.display = "";
		document.getElementById("ttext_instructions").style.display = "";
		}
	}

function tablerow(l,fl) {
	var number_display_format = "factored" //"number" or "factored"
	var display_fractions = false; //show fractions in each row or maybe just leave them to top?
	var i;
	var rawfl = fl_to_rawfl(fl);
	var k = apply_fl_to_l_and_which(l, fl); //k[0] is the new number, k[1] is which fraction got multiplied, or maybe k is just "nope"

	var str = "<tr><td>";
	if (number_display_format == "number") {
		str += pl_to_int(l);
		}
	else if (number_display_format == "factored") {
		str += rawpl_to_html(pl_to_rawpl(l));
		}
	str += "</td>";

	for (i = 0; i < fl.length; i++) {
		if (i == k[1]) {
			str += "<td style='background-color:"+hi_color(i)+"'>";
			}
		else {
			str += "<td>";
			}
		if (display_fractions) {
			str += rawplfrac_to_html(rawfl[i][0],rawfl[i][1]);
			}
		str += "</td>";
		}

	str += "<td>";
	if (k == "nope") {
		str += "Done!";
		}
	else if (number_display_format == "number") {
		str += pl_to_int(k[0]);
		}
	else if (number_display_format == "factored") {
		str += rawpl_to_html(pl_to_rawpl(k[0]));
		}
	str += "</td>";

	str += "</tr>";

	return(str);
	}

function generate_table_html(nh, fl) { //meant to be fed in g_number_history and g_fracl. note there are no assumptions on nh: you could make a table of what happens if you input 1 to n. outputs an HTML string
	var str = "<table border=1 style='background-color:white'>";
	var top_fractions = true; //show fractions at the top
	var i, j;
	var rawfl = fl_to_rawfl(fl);

	if (top_fractions) {
		str += "<tr><td></td>";
		for (i = 0; i < fl.length; i++) {
			str += "<td>";
			str += rawplfrac_to_html(rawfl[i][0],rawfl[i][1]);
			str += "</td>";
			}
		str += "<td></td></tr>";
		}

	for (i = 0; i < nh.length; i++) {
		str += tablerow(nh[i], fl);
		}

	str += "</table>";
	return(str);
	}

var g_number_history = []; //history. list of pls of the numbers

function reset_runtable() {
	g_number_history = [];
	document.getElementById("runtable").innerHTML = "";
	}

function butt_once() { //might make this fancier later
	if (g_number_history.length == 0) {
		//var k = Number(document.getElementById("number_in").value);
		//var l = prime_factor(k);
		var l = rawpl_to_pl(str_to_rawpl(document.getElementById("number_in").value));
		g_number_history.push(l);
		}

	var last_pl = g_number_history[g_number_history.length-1];
	var next_pl = apply_fl_to_l(last_pl, g_fracl)
	if (next_pl != "nope") {
		g_number_history.push(next_pl);
		}

	var str = generate_table_html(g_number_history, g_fracl);

	document.getElementById("runtable").innerHTML = str;
	}

function butt_many() {
	var i;
	for (i = 0; i < 1000; i++) {
		if (g_number_history.length == 0) {
			var l = rawpl_to_pl(str_to_rawpl(document.getElementById("number_in").value));
			g_number_history.push(l);
			}
		var last_pl = g_number_history[g_number_history.length-1];
		var next_pl = apply_fl_to_l(last_pl, g_fracl)
		if (next_pl == "nope") { break; }
		g_number_history.push(next_pl);
		}

	var str = generate_table_html(g_number_history, g_fracl);

	document.getElementById("runtable").innerHTML = str;
	if ("testing_ground_level" in levels[g_current_level]) {
		local_data.levels[g_current_level].completed = true;
		store_local_data();
		}
	}

function load_program(str) {
	document.getElementById("text_in").value = str;
	do_text_in();
	}

var g_current_level = 0;

function load_level(i) {
	var str = "";
	if ("guide" in levels[i]) {
		str += levels[i].guide;
		str += "<hr>";
		};
	str += levels[i].desc;
	g_current_level = i;
	str += " <button onclick='test_level(g_current_level)'>Test Solution</button>";
	document.getElementById("level_text").innerHTML = str;
	document.getElementById("check_out").innerHTML = "";

	var loaded_rawfl = local_data.levels[g_current_level].program;
	document.getElementById("text_in").value = rawfl_to_str(loaded_rawfl);
	MQ(document.getElementById("mq_in")).latex(rawfl_to_latex(loaded_rawfl));
	do_text_in();
	}

function test_level(i) {
	g_check_out_string = "";
	var k = levels[i].test();
	if (k) {
		document.getElementById("check_out").innerHTML = "All tests " + passstr + "<br><table border=1>" + g_check_out_string + "</table>";
		local_data.levels[i].completed = true;
		store_local_data();
		}
	else {
		document.getElementById("check_out").innerHTML = "Some tests " + failstr + "<br><table border=1>" + g_check_out_string + "</table>";
		}
	}

function compare_pls(pl1,pl2) {
	var i;
	for (i = 0; i < Math.max(pl1.length,pl2.length); i++) {
		if ((i in pl1) && (i in pl2) && (pl1[i] != pl2[i])) {return(false);}
		if (!(i in pl1) && (i in pl2) && (pl2[i] != 0)) {return(false);}
		if ((i in pl1) && !(i in pl2) && (pl1[i] != 0)) {return(false);}
		}
	return(true);
	}

var g_check_out_string = "";

function checkotron(in_pl,out_pl,hard_steps = -1) { //checks to see if in_pl creates out_pl, returns boolean, updates g_check_out_string
	var str = "<tr><td>" + rawpl_to_html(pl_to_rawpl(in_pl)) + "</td>";
	var runstr = "";
	var statusstr = "";
	var max_iterations = 1000;
	var visited_numbers = {};
	var current_pl = in_pl;
	visited_numbers[pl_to_int(current_pl)] = true;
	var rval = false;
	var i;
	runstr += rawpl_to_html(pl_to_rawpl(current_pl));
	for (i = 0; i < max_iterations; i++) {
		var t = apply_fl_to_l_and_which(current_pl,g_fracl);
		if (t == "nope" || i == hard_steps) {
			if (compare_pls(out_pl,current_pl)) {
				rval = true;
				statusstr = passstr + " Expected: " + rawpl_to_html(pl_to_rawpl(out_pl));
				}
			else {
				statusstr = failstr + " Got: " + rawpl_to_html(pl_to_rawpl(current_pl)) + " Expected: " + rawpl_to_html(pl_to_rawpl(out_pl));
				}
			break;
			}
		next_pl = t[0];
		var next_pl_html_string = rawpl_to_html(pl_to_rawpl(next_pl));
		if (pl_to_int(next_pl) in visited_numbers) {
			runstr += arrowtron(t[1]) + next_pl_html_string;
			statusstr = "Loop!";
			break;
			}
		runstr += arrowtron(t[1]) + next_pl_html_string;
		current_pl = next_pl;
		}
	str += "<td>" + statusstr + "</td>";
	str += "<td>" + runstr + "</td>";
	str += "</tr>";
	g_check_out_string += str;
	return(rval);
	}

function call_this_on_changing_local_data() { //changes visual components reflecting local data
	update_level_select();
	if (local_data.no_cancel_unlocked) {
		document.getElementById("chk_no_cancel_container").style.display = "";
		}
	else {
		document.getElementById("chk_no_cancel_container").style.display = "none";
		document.getElementById("chk_no_cancel").checked = false;	
		}
	}

function reset_local_data() {
	localStorage.clear();
	var local_level_data = [];
	var i;
	for (i = 0; i < levels.length; i++) {
		var prg = [];
		if ("preprogram" in levels[i]) {prg = levels[i].preprogram;}
		local_level_data.push({
			completed: false,
			program: prg,
			notes: []
			});
		}
	local_data.levels = local_level_data;
	local_data.no_cancel_unlocked = false;
	store_local_data();
	}

function boot_local_data() {
	if (!localStorage.getItem("trkern_fractran_local_data")) {
		reset_local_data();
		}
	else {
		var lld_string = localStorage.getItem("trkern_fractran_local_data");
		local_data = JSON.parse(lld_string);
		call_this_on_changing_local_data();
		}
	}

function store_local_data() {
	localStorage.setItem("trkern_fractran_local_data", JSON.stringify(local_data));
	call_this_on_changing_local_data();
	}

function update_level_select() {
	var k = document.getElementById("sel_lev");
	if (k) {
		k = k.value;
		}
	var i;
	var str = "<select id='sel_lev' onchange='load_level(event.target.value)'>";
	for (i = 0; i < levels.length; i++) {
		if (i == k) {
			str += "<option value="+i+" selected>";
			}
		else {
			str += "<option value="+i+" >";
			}
		if (local_data.levels[i].completed) {
			str += "+";
			}
		else {
			str += "-";
			}
		str += i+": "+levels[i].name+"</option>";
		}
	str += "</select>";
	document.getElementById("level_sel").innerHTML = str;
	}

function boot() {
	MQ.MathField(document.getElementById("mq_in"), {
		handlers: {
			edit: do_mq_in,
			},
		charsThatBreakOutOfSupSub: '+-=<>*/'
		});
	boot_local_data();
	do_sel_inp();
	load_level(0);
	}

var levels = [];
levels.push({
	testing_ground_level: true,
	preprogram: str_to_rawfl("17/91 78/85 19/51 23/38 29/33 77/29 95/23 77/19 1/17 11/13 13/11 15/2 1/7 55/1"),
	name: "Welcome to Fractran!",
	guide: "<p>Welcome to <code>FRACTRAN</code>! <code>FRACTRAN</code> is a Turing-complete programming language created by John Conway. This interactive will guide you through some basic programming practice in <code>FRACTRAN</code> until you are an EXPERT <code>FRACTRAN</code> PROGRAMMER!</p><p>A program in <code>FRACTRAN</code> is a list of fractions.</p> Execution:<ul><li> The program takes in a number as an input and stores it in the STATE VARIABLE<li> At each step of execution, the STATE VARIABLE number gets multiplied by the first fraction in your program that leaves the number as an integer.<li> This process repeats: the new STATE VARIABLE is multiplied by the FIRST fraction in your program that leaves the number as an integer.<li> If no fraction is available, the program HALTS and outputs the current STATE VARIABLE.</ul>",
	desc: "Each level will ask you to create a program to perform a certain task. This level has been pre-programmed with the PRIMEGAME program. <ol><li>Scroll down to the 'Testing Ground'<li>Enter the number 2<li>Press the 'Advance 1000 Steps' button a few times.<li>A little + will appear in the level select to indicate that you've completed this level.</ol>"
	});

levels.push({
	name: "Introduction",
	guide: "<p>A program in <code>FRACTRAN</code> is a list of fractions. Several INPUT DEVICES have been provided for you below: you can read about each one by selecting it from the drop down menu. Please choose the input device that works best for you!</p>Execution:<ul><li> The program takes in a number as an input and stores it in the STATE VARIABLE<li> At each step of execution, the STATE VARIABLE number gets multiplied by the first fraction in your program that leaves the number as an integer.<li> This process repeats: the new STATE VARIABLE is multiplied by the FIRST fraction in your program that leaves the number as an integer.<li> If no fraction is available, the program HALTS and outputs the current STATE VARIABLE.</ul>",
	desc: "Create a program that maps 2 to 3. Press the 'Test Solution' button to check your answer.",
	test: function() {
		return(checkotron([1],[0,1]));
		}
	});

levels.push({
	name: "Multiple Fractions",
	guide: "<p>REMEMBER: your program can consist of multiple fractions! At each step, the number gets multiplied by the first fraction that keeps it a whole number, and ignores the rest.</p>",
	desc: "Create a program that maps 2 to 3 and 5 to 7.",
	test: function() {
		var rval = true;
		if (!checkotron([1],[0,1])) {rval = false;}
		if (!checkotron([0,0,1],[0,0,0,1])) {rval = false;}
		return(rval);
		}
	});

levels.push({
	name: "Order Matters",
	guide: "<p>REMEMBER: the order of fractions in your program matters! At each step, the number gets multiplied by the FIRST fraction that keeps it a whole number, and ignores the rest. In other words, the order of fractions is not the order to carry the instructions out, but an order of PRIORITY.</p>",
	desc: "Create a program that maps 2 to 5, 3 to 7, and 6 to 11.",
	test: function() {
		var rval = true;
		if (!checkotron([1],[0,0,1])) {rval = false;}
		if (!checkotron([0,1],[0,0,0,1])) {rval = false;}
		if (!checkotron([1,1],[0,0,0,0,1])) {rval = false;}
		return(rval);
		}
	});

levels.push({
	name: "Introduction Again",
	guide: "<p>This process of multiplying the current number by the first fraction happens repeatedly until there is no fraction in the list that can be multiplied by the current number to get an integer.</p>",
	desc: "Create a program that maps 2<sup>n</sup> to 3<sup>n</sup>.",
	test: function() {
		var rval = true;
		for (var i = 0; i < 10; i++) {
			if (!checkotron([i],[0,i])) {rval = false;}
			}
		return(rval);
		}
	});

levels.push({
	name: "Multiple Fractions Again",
	guide: "<p>This process of multiplying the current number by the first fraction happens repeatedly until there is no fraction in the list that can be multiplied by the current number to get an integer.</p>",
	desc: "Create a program that maps 2<sup>n</sup> to 3<sup>n</sup> and 5<sup>n</sup> to 7<sup>n</sup>.",
	test: function() {
		var rval = true;
		for (var i = 0; i < 7; i++) {
			if (!checkotron([i],[0,i])) {rval = false;}
			}
		for (var i = 0; i < 7; i++) {
			if (!checkotron([0,0,i],[0,0,0,i])) {rval = false;}
			}
		return(rval);
		}
	});

levels.push({
	name: "Deleting Data",
	guide: "<p>Looking at numbers in terms of their prime factorizations is essential to understanding a <code>FRACTRAN</code> program.</p>",
	desc: "Create a program that maps 2<sup>n</sup> 3<sup>m</sup> to 2<sup>n</sup>.",
	test: function() {
		var rval = true;
		for (var i = 0; i < 6; i++) {
			for (var j = 0; j < 6; j++) {
				if (!checkotron([i,j],[i])) {rval = false;}
				}
			}
		return(rval);
		}
	});

levels.push({
	name: "Copying Data",
	desc: "Create a program that turns 2<sup>n</sup> into 3<sup>n</sup> 5<sup>n</sup>.",
	test: function() {
		var rval = true;
		for (var i = 0; i < 10; i++) {
			if (!checkotron([i],[0,i,i])) {rval = false;}
			}
		return(rval);
		}
	});

levels.push({
	name: "Addition",
	desc: "Create a program that turns 2<sup>n</sup> 3<sup>m</sup> into 5<sup>n+m</sup>.",
	test: function() {
		var rval = true;
		for (var i = 0; i < 7; i++) {
			for (var j = 0; j < 7; j++) {
				if (!checkotron([i,j],[0,0,i+j])) {rval = false;}
				}
			}
		return(rval);
		}
	});

levels.push({
	name: "Doubling",
	desc: "Create a program that turns 2<sup>n</sup> to 3<sup>2n</sup>.",
	test: function() {
		var rval = true;
		for (var i = 0; i < 10; i++) {
			if (!checkotron([i],[0,2*i])) {rval = false;}
			}
		return(rval);
		}
	});

levels.push({
	name: "Intermediate Registers",
	desc: "Create a program that turns 2<sup>n</sup> to 3<sup>2n</sup>, but none of the numerators in your program can have a power of 3 larger than 1.",
	test: function() {
		var rval = true;
		for (var i = 0; i < g_fracl.length; i++) {
			if (g_fracl[i][0][1] >= 2) {
				g_check_out_string += failstr + " Fraction contains numerator divisible by 9.";
				rval = false;
				}
			}
		for (var i = 0; i < 10; i++) {
			if (!checkotron([i],[0,2*i])) {rval = false;}
			}
		return(rval);
		}
	});

levels.push({
	name: "Subtraction",
	desc: "Create a program that turns 2<sup>n</sup> 3<sup>m</sup> (for n < m) into 3<sup>m-n</sup>.",
	test: function() {
		var rval = true;
		for (var i = 0; i < 7; i++) {
			for (var j = i+1; j < 7; j++) {
				if (!checkotron([i,j],[0,j-i])) {rval = false;}
				}
			}
		return(rval);
		}
	});

levels.push({
	name: "Proper Subtraction",
	desc: "Create a program that turns 2<sup>n</sup> 3<sup>m</sup> into 5<sup>|m-n|</sup>.",
	test: function() {
		var rval = true;
		for (var i = 0; i < 7; i++) {
			for (var j = 0; j < 7; j++) {
				if (!checkotron([i,j],[0,0,Math.abs(j-i)])) {rval = false;}
				}
			}
		return(rval);
		}
	});

levels.push({
	name: "Remainders",
	desc: "Create a program that turns 2<sup>k</sup> into 1 if k is even and 3 if k is odd.",
	test: function() {
		var rval = true;
		for (var i = 0; i < 5; i++) {
			if (!checkotron([2*i],[])) {rval = false;}
			if (!checkotron([2*i+1],[0,1])) {rval = false;}
			}
		return(rval);
		}
	});

levels.push({
	name: "Control",
	guide: "<p>We've seen the primes' exponents acting as registers to temporarily store data, but they can just as easily serve as booleans (0 or 1) to control the flow of our programs, executing different code depending on which of a list of primes is present.</p>",
	desc: "Create a program that turns 2<sup>n</sup>11 into 2<sup>n+1</sup> and 2<sup>n</sup>17 into 2<sup>n-1</sup>",
	test: function() {
		var rval = true;
		for (var i = 0; i < 7; i++) {
			if (!checkotron([i,0,0,0,1],[i+1])) {rval = false;}
			}
		for (var i = 1; i < 7; i++) {
			if (!checkotron([i,0,0,0,0,0,1],[i-1])) {rval = false;}
			}
		return(rval);
		}
	});

levels.push({
	name: "Control 2",
	guide: "<p>Control is a bit tricky in <code>FRACTRAN</code>. When a program reads a control prime present in the current number, it consumes it, and one cannot put it back directly without creating fractions that cancel (losing their utility). Try the next level for a hint.</p>",
	desc: "Create a program that turns 2<sup>n</sup>11 into 3<sup>n</sup>11 and 2<sup>n</sup>17 into 5<sup>n</sup>17",
	test: function() {
		var rval = true;
		for (var i = 0; i < 7; i++) {
			if (!checkotron([i,0,0,0,1],[0,i,0,0,1])) {rval = false;}
			}
		for (var i = 0; i < 7; i++) {
			if (!checkotron([i,0,0,0,0,0,1],[0,0,i,0,0,0,1])) {rval = false;}
			}
		return(rval);
		}
	});

levels.push({
	name: "Control 2 Hint",
	desc: "Create a program that turns 2<sup>n</sup>11 into 2<sup>n+1</sup>13 and 2<sup>n</sup>17 into 2<sup>n-1</sup>19",
	test: function() {
		var rval = true;
		for (var i = 0; i < 7; i++) {
			if (!checkotron([i,0,0,0,1],[i+1,0,0,0,0,1])) {rval = false;}
			}
		for (var i = 1; i < 7; i++) {
			if (!checkotron([i,0,0,0,0,0,1],[i-1,0,0,0,0,0,0,1])) {rval = false;}
			}
		return(rval);
		}
	});

levels.push({
	name: "Remainders 2",
	guide: "Having a control prime present in the input opens up some additional possibilities.",
	desc: "Create a program that turns 2<sup>n</sup>11 into 5 if n is even and 3 if n is odd.",
	test: function() {
		var rval = true;
		for (var i = 0; i < 7; i++) {
			if (!checkotron([2*i,0,0,0,1],[0,0,1])) {rval = false;}
			if (!checkotron([2*i+1,0,0,0,1],[0,1])) {rval = false;}
			}
		return(rval);
		}
	});

levels.push({
	name: "Unlocking nocancel",
	guide: "Constantly having to swap back and forth between control primes is a real nuisance. If only fractions didn't cancel, since this <code>FRACTRAN</code> interpreter first checks divisibility by the denominator before multiplying by the numerator, you could write programs much more simply! For instance, the program "+rawfl_to_html(str_to_rawfl("3*11/2*11, 5*17/2*17"))+ " would be a shorter solution to 'Control 2'. Complete this stage to unlock nocancel mode.",
	desc: "Create a program that, when run for two steps on a number, is the same as running the un-canceled program " + rawfl_to_html(str_to_rawfl("2^3*5^4*11/2^4*5^3*11")) + " i.e. " + rawfl_to_html(str_to_rawfl("55000/22000")) + " for one step. That is, if the number is divisible by 22000, in two steps it divides by 22000 and multiplies by 55000 and otherwise does nothing.",
	test: function() {
		var rval = true;
		for (var i = 2; i <= 5; i++) {
			for (var j = 2; j <= 5; j++) {
				for (var k = 0; k <= 2; k++) {
					var t = [i,0,j,0,k];
					if (i >= 4 && j >= 3 && k >= 1) {
						t = [i-1,0,j+1,0,k];
						}
					if (!checkotron([i,0,j,0,k], t, 2)) {rval = false;}
					}
				}
			}
		if (rval) {
			local_data.no_cancel_unlocked = true;
			}
		return(rval);
		}
	});

levels.push({ //11/13, 3*5*13/2*11, 19/11, 17/19, 19*2/5*17
	name: "There and Back",
	desc: "Create a program that turns 2<sup>n</sup>11 into 2<sup>n</sup>3<sup>n</sup>17.",
	test: function() {
		var rval = true;
		for (var i = 0; i < 7; i++) {
			if (!checkotron([i,0,0,0,1],[i,i,0,0,0,0,1])) {rval = false;}
			}
		return(rval);
		}
	});


var local_data = {};

var sample_primegame = "17/91 78/85 19/51 23/38 29/33 77/29 95/23 77/19 1/17 11/13 13/11 15/2 1/7 55/1"

</script>
<style>
@font-face {
	font-family: "tech";
	src: url("VT323-Regular.ttf");
	}
body{
	font-size:large;
	font-family: sans-serif;
	}
code {
	font-family: "tech", monospace;
	font-size: 120%;
	}
</style>
</head>
<body onload="boot()">

<h1 style="left:0;right:0;margin:auto;text-align:center"><code>FRACTRAN</code></h1>

<span style='background-color: #266435; margin-left:10px; margin-right:10px; margin-bottom:0px; font-size:175%;color:white; font-family:tech'>
Level Select:
<span id="level_sel">
</span> <button onclick="reset_local_data()">Reset Progress</button>
</span>

<div style='background-color: #CCDDAA; padding:10px; margin:10px; margin-top:0px'>
<div id="level_text">
</div>
</div>

<div id="check_out"></div>

<span style='background-color: #266435; margin-left:10px; margin-right:10px; margin-bottom:0px; font-size:175%;color:white; font-family:tech'>
Input Device: <select id="sel_inp" onchange="do_sel_inp(event)">
<option value="tmq">TKAS Mathquill</option>
<option value="text" selected>Text</option>
</select>
</span>

<div style='background-color: #CCDDAA; padding:10px; margin:10px; margin-top:0px'>
<span id="chk_no_cancel_container"><input type="checkbox" id="chk_no_cancel" onchange="do_chk_no_cancel()"> nocancel </span>
<div id="text_in_area">
<div id="ttext_instructions">
Using TKAS.js to parse. Separate fractions with commas. Please report bugs. Needing parentheses around denominators which are products is not a bug. If you encounter problems, drop down to "Backup Text".
</div>
<div id="text_instructions">
<ul>
<li> Fractions are separated with spaces or commas.
<li> Separate numerator and denominator with "/". Do not include spaces within a fraction.
<li> Numerator and denominator should be products of numbers (to powers).
<li> Enter powers with "^".
<li> Multiply with "*".
<li> Do not use parentheses.
</ul>
<p>Example Program: 7*3*11/2^3*5, 3*5^6/7*11^12*13, 4/3^2</p>
</div>
<textarea type="text" id="text_in" oninput="do_text_in()"></textarea>
</div>

<div id="demos_in_area">
<div id="demos_in">
<button onclick="load_program(sample_primegame)">Primegame</button>
</div>
</div>

<div id="mq_in_area">
<div id="tmq_instructions">
Using TKAS.js to parse. Separate fractions with commas. Use LEFT ARROW to break out of exponents and fractions. Please report bugs. If you encounter parse errors, drop down to "Backup Mathquill".
</div>
<div id="mq_instructions">
<ul>
<li> Fractions can be separated by spaces or commas.
<li> Use "/" and "^" to create fractions, exponents.
<li> Use arrow keys to navigate / break out of exponents and fractions.
<li> Numerator and denominator should be products of numbers (to powers).
<li> Multiply with "*".
<li> Do not use parentheses.
</ul>
</div>
<div id="mq_in" style='background-color:white'></div>
</div>
<button onclick='test_level(g_current_level)'>Test Solution</button>
</div>

<span style='background-color: #266435; margin-left:10px; margin-right:10px; margin-bottom:0px; font-size:175%;color:white;  font-family:tech'>Your Program:
</span>

<div style='background-color: #CCDDAA; padding:10px; margin:10px; margin-top:0px'>
<div id="flist_out" style="overflow-x:auto;white-space:nowrap"></div>
</div>

<span style='background-color: #266435; margin-left:10px; margin-right:10px; margin-bottom:0px; font-size:175%;color:white;  font-family:tech'>Testing Ground:</span>

<div style='background-color: #CCDDAA; padding:10px; margin:10px; margin-top:0px'>
<input type="text" id="number_in" oninput="reset_runtable()"> <button onclick="butt_once()">Advance One Step</button> <button onclick="butt_many()">Advance 1000 Steps</button>
<div id="runtable"></div>
</div>

<div id="optionbox" style='background-color: #DDDDDD;position:fixed; right:0px; top:0px'>
Options
</div>



</body>
</html>